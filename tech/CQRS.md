---
title: CQRS
type: Study/Backend
releation: Event Sourcing
---

# CQRS

### 기존 CRUD 문제
- 읽기 및 쓰기 작업은 매우 다양 한 성능 및 확장 요구 사항을 가진 비대칭 인 경우가 많음
- 각 엔터티는 읽기 및 쓰기 작업을 수행 하므로 잘못 된 컨텍스트에서 데이터를 노출할 수 있기 때문에 보안 및 사용 권한 관리가 복잡해질 수 있음
- 데이터 저장소 및 데이터 액세스 계층에 대 한 로드로 인해 성능에 부정적인 영향을 미칠 수 있으며, 정보를 검색 하는 데 필요한 쿼리의 복잡성이 있음

### CQRS 란?
- CQRS (명령과 쿼리의 역할 분리) 패턴은 데이터 저장소에 대 한 읽기 및 업데이트 작업을 분리, 데이터를 업데이트하는 명령을 사용하고 데이터를 읽는 쿼리를 사용하여 읽기 및 쓰기를 다른 모델로 분리
- 응용 프로그램에서 CQRS를 구현 하면 성능, 확장성 및 보안에 대한 장점이 있음
- 시간이 지남에 따라 업데이트 명령으로 인해 도메인 수준에서 병합 충돌이 발생하는 것을 방지

### CQRS 논리
> 더 높은 격리 수준을 위해 쓰기 데이터에서 읽기 데이터를 물리적으로 구분할 수 있습니다. 이 경우에 읽기 데이터베이스는 쿼리에 대해 최적화된 고유한 데이터 스키마를 사용할 수 있습니다. 예를 들어 복잡한 조인이나 복잡한 O/RM 매핑을 방지하기 위해 데이터의 구체화된 뷰를 저장할 수 있습니다(materialized-view-pattern). 다른 유형의 데이터 저장소도 사용할 수 있습니다. 예를 들어 쓰기 데이터베이스가 관계형일 수 있는 반면 읽기 데이터베이스는 문서 데이터베이스입니다.
> 읽기 및 쓰기 저장소를 분리하면 부하를 감안해 각 저장소를 적절하게 확장할 수도 있습니다. 보통 읽기 저장소는 쓰기 저장소보다 부하가 훨씬 더 높습니다.
> CQRS의 일부 구현에서는 이벤트 소싱 패턴을 사용합니다. 이러한 패턴에서 애플리케이션 상태는 이벤트의 시퀀스로 저장됩니다. 각 이벤트는 데이터에 대한 변경 집합을 나타냅니다. 현재 상태는 이벤트를 재생함으로써 구축됩니다. CQRS 컨텍스트에서 이벤트 소싱의 이점 중 하나는 다른 구성 요소 —를 알리는 데 동일한 이벤트를 사용할 수 있다는 점입니다. 특히 읽기 모델에 알립니다. 읽기 모델은 현재 상태의 스냅샷을 만드는 데 이벤트를 사용합니다. 이것이 쿼리에 보다 효과적입니다. 그러나 이벤트 소싱은 디자인에 복잡성을 추가합니다.

### 장점
- 단순한 쿼리 읽기 데이터베이스에서 구체화된 뷰를 저장하여 쿼리할 때 애플리케이션은 복잡한 조인을 방지
- 읽기 쪽에서는 쿼리에 최적화된 스키마를 사용하는 반면 쓰기 쪽에서는 업데이트에 최적화된 스키마를 사용할 수 있음
- 보안. 올바른 도메인 엔터티만 데이터에서 쓰기를 수행할 수 있는지 쉽게 확인할 수 있음
- 읽기 및 쓰기 쪽을 구분하면 유지 가능하고 유연한 모델을 생성. 대부분의 복잡한 비즈니스 논리는 쓰기 모델. 읽기 모델은 상대적으로 간단할 수 있음

### 단점
- 복잡성. CQRS의 기본 개념은 간단하지만 이벤트 소싱 패턴을 포함하는 경우에 복잡한 어플리케이션 디자인을 만들 수 있음
- 명령을 처리하고 업데이트 이벤트를 게시하는데 공통적으로 메시징을 사용하기 때문에 메시지 오류 또는 중복을 처리해야함
- 일관성. 읽기 및 쓰기 데이터 베이스를 구분하는 경우 저장소의 일관성에 대해 보장해야함